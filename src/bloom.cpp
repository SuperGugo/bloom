//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡀⠤⠤⡤⠤⣀⡄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠴⣋⡭⠴⠌⠃⠹⠴⠧⣒⡴⢡⠛⡢⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠝⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠫⣔⢢⢳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⡤⢻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣆⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡍⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣤⣄⠀⠀⠀⠀⠀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢰⠀⣇⣀⣀⣀⣠⣫⣔⣩⣓⣤⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠤⡔⣒⢒⠳⡌⣍⠻⡇⢨⠐⡏⣧⠙⡁⣧⣹⠁⡏⢸⢹⡌⢏⢹⣌⡗⣄⠢⡔⢠⠒⡞⠤⢤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⢀⣠⠴⡒⢭⠣⣙⢢⠱⣌⣪⠵⢖⡨⠱⣇⠸⢀⣇⠛⢠⠄⣿⢿⠐⠇⢸⡸⠃⣎⢸⣹⡿⣶⢷⢾⡇⡹⢌⠓⡆⢦⢩⡑⠲⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⢀⣤⠲⢍⡱⢊⡱⣊⢴⡳⢛⡍⠳⣌⠚⡤⢣⢍⡛⣛⠫⣙⢛⢻⣟⡋⣿⠛⡇⢸⡙⢏⡛⢻⡘⣛⠛⣛⢛⢣⡑⢎⡱⢚⠤⢣⠜⣡⢋⡌⡓⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⣠⣔⠯⠔⠓⠊⣑⠛⠉⢰⢅⢣⠣⢜⡱⢌⠳⣌⠣⢎⠴⣡⠓⡌⢎⣽⠀⠓⠼⣳⡖⠯⡙⢢⡙⢢⠱⡌⠳⡌⢎⠦⣉⠦⡱⣉⢎⡱⢊⡕⢪⠔⡩⢆⡹⢦⡀⠀⠀⠀⠀⠀⠀⠀
//⠘⠉⠀⠀⠀⡠⠊⠀⠀⠀⠀⠉⢚⠇⠺⠐⠉⠖⠌⠓⠬⢒⣥⢙⡘⢆⡚⠀⠀⠀⠀⠈⠉⠙⠃⠘⠃⠳⠌⠳⣘⠌⡖⡡⢎⡑⢆⠎⡔⢣⠜⣡⢚⡱⢊⠴⣡⠙⣦⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⡠⠊⠀⠀⠀⠀⠀⠀⣰⡁⣠⠠⢤⢄⡒⢢⠒⣌⢣⡏⢦⢙⡂⣯⡀⢤⠠⣄⠢⡔⣂⠖⣒⢲⡒⡔⣒⠰⢢⠌⡅⢎⡜⣌⠚⣌⢣⠚⡤⢣⠜⣩⠒⡥⡙⡌⢧⠀⠀⠀⠀⠀
//⠀⢠⠊⠀⠀⢀⣀⠤⢔⣲⠯⡑⢦⢡⢋⠖⣌⠎⡥⢋⡔⣟⡘⢆⠣⣜⢾⢌⢣⠣⣌⠳⡇⡜⡸⢄⡟⡦⠱⣌⢣⢃⠞⡘⢦⡘⢤⢋⡔⢣⡙⡔⢣⠚⡔⣫⠔⡱⢌⡍⢧⠀⠀⠀⠀
//⡠⢁⢠⠔⣪⠱⣈⠞⡼⣃⢎⡱⢊⠦⣉⠞⢤⢋⡔⢣⢼⡣⠜⣌⢣⡝⢸⠌⣆⠳⣌⢺⡕⡬⡑⢎⡇⢣⡓⡔⣊⣮⢘⡱⢢⠍⣆⠣⡜⣡⠚⣌⢣⡙⡌⣷⢊⡕⢪⠜⡌⡇⠀⠀⠀
//⢔⡉⢦⡙⣄⣳⢇⡾⡓⡌⢦⠱⣉⡖⣡⠚⡤⢣⠜⣡⣾⢡⢋⡔⣺⠀⢸⡘⢤⠓⡌⢾⣱⢻⡘⢼⠁⢸⡔⡱⢸⣟⡦⣑⠣⡚⢤⠓⡜⢤⢋⠤⣷⠰⡡⣟⢢⠜⣡⠚⡔⣋⠀⠀⠀
//⠬⣘⡢⠕⡽⣑⡾⢡⠓⡜⢢⢓⡼⢱⢡⢋⡔⢣⠚⣴⣿⣢⣧⣜⡇⠀⠐⡏⢦⡙⣌⡻⣼⣻⠘⡼⠀⠈⡧⣱⠶⢾⢻⡤⣧⣙⠤⣋⠜⡢⢍⠲⣹⡇⡱⢿⡌⢎⠥⣋⠴⣹⠀⠀⠀
//⡶⠋⠀⡞⡱⣾⢡⢣⡙⣌⠣⣾⢃⠇⣎⠲⣌⠣⣽⣟⣿⢡⠒⣼⠀⠈⠀⣿⠰⡘⢤⡟⣵⣯⠘⡷⠀⠀⢳⠡⢎⢽⠨⣳⡔⣩⠻⣦⡙⠴⣉⠖⣹⣧⠱⣿⡘⡌⢖⡡⢒⡱⡆⠀⠀
//⠀⠀⣼⢡⣿⢃⠎⢦⠱⢌⣲⡏⡜⡸⢄⠳⣌⠱⣿⢮⣿⢄⢫⡇⠀⠀⠀⢱⢣⡙⢆⡿⣱⢿⣈⡇⠀⠀⠘⣧⢊⢼⠀⠣⢿⡠⢓⠬⣑⠣⡜⡘⢼⣧⣹⢿⠰⣉⠦⣑⢣⠒⡇⠀⠀
//⠀⣸⢣⠋⡜⣌⠺⡰⣉⢶⣿⡘⠴⡑⢎⡱⢌⣹⢷⡿⢸⢌⣺⠀⠀⠀⠀⠈⡧⠜⣌⠷⣏⣿⣸⠁⠀⠀⠀⢹⡌⢲⠄⠀⠭⢷⣉⠖⣡⠓⡬⡑⢎⣽⣛⣾⠱⣌⠲⡡⢎⡱⡇⠀⠀
//⠀⣮⠊⢰⠱⣌⢣⠱⣌⡿⣧⡘⢥⡙⢦⡑⢎⣾⣻⠱⠸⡆⡷⠀⠀⠀⠀⠀⢹⡜⡌⣿⢺⣼⣻⠀⠀⠀⠀⠘⣯⢸⡇⠀⠈⢎⢷⡜⢤⢋⠴⣉⠆⣿⣟⣾⢑⡎⡱⡑⢎⡔⡇⠀⠀
//⣸⠃⠀⣨⠱⣌⢒⠣⣼⡻⣇⠜⣢⠙⡴⡘⢬⣷⡏⠃⠀⡧⠇⠀⠀⠀⠀⠀⠈⢷⢌⡳⢯⣾⡝⠀⠀⠀⠀⠀⠹⡼⡁⠀⠀⠈⢊⢿⢠⢋⠖⣡⠚⣼⣻⣼⢾⡡⢣⡙⢢⠜⡇⠀⠀
//⡇⠀⠀⢹⠶⡈⡎⢱⣏⢷⡇⠾⣀⠏⣰⠉⣾⣹⠹⠀⠰⢿⠀⠀⠶⠶⠶⡀⠀⠈⣶⢹⡷⣾⡇⠀⠀⠀⠀⣈⣁⣹⡷⠆⠰⠆⢀⡎⣇⡉⠾⣀⠏⣰⢿⣾⢿⣰⢇⡸⢁⡎⡇⠀⠀
//⠁⠀⠀⢻⡰⢱⡘⣹⣎⢺⡇⠳⣌⠚⡤⡙⣶⡟⣷⣶⣶⣿⣿⣿⣿⣿⣿⠏⠀⠀⠸⣧⢟⡶⡇⠀⠀⠀⠀⠺⣿⣿⣿⣿⣶⣶⣦⣴⣽⣮⣱⢌⡚⢬⣿⢾⣯⠿⣠⢃⠧⣘⠃⠀⠀
//⠀⠀⠀⣳⢌⠣⡜⡹⢤⠇⣏⠳⣈⠳⡰⢡⣿⠁⣿⠀⣸⣿⣿⣿⣿⣿⣿⠄⠀⠀⠀⠹⣯⢞⡇⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⠛⣿⡟⠢⢍⠆⣿⣿⣺⡗⠤⢣⡚⢼⠀⠀⠀
//⠀⠀⠀⢺⢨⠱⡌⡱⡞⠀⢡⡓⣌⢣⠱⡡⣾⡆⠙⡇⠈⠀⠈⣿⣾⣿⣾⠀⠀⠀⠀⠀⠹⣯⡇⠀⠀⠀⠀⠀⠁⠀⢹⣷⣿⣯⣿⡿⢀⡏⣿⡑⢪⠜⣽⡿⡽⠮⣕⠩⢷⢺⠀⠀⠀
//⠀⠀⠀⢸⡄⠳⡌⡽⠀⠀⠘⡕⡌⢆⢣⡑⣿⣻⡀⠰⠘⣤⡶⢿⣿⡾⣿⡀⠀⠀⠀⠀⠀⠹⣷⠀⠀⠀⠀⠀⣶⣤⣾⣽⠷⠻⣷⡇⢈⠀⣿⡏⢦⠙⣺⣿⣃⡀⠘⣧⠚⣯⠀⠀⠀
//⠀⠀⠀⠈⣇⠳⢌⡇⠀⠀⠀⢹⡘⡌⢦⢹⣿⡹⣇⠀⠀⢻⣇⠀⠁⢂⣼⠆⠀⠀⠀⠀⠀⠀⠹⠄⠀⠀⠀⠀⢻⣿⠀⠀⠁⢠⡿⢀⠂⢸⡷⣻⡆⡹⢼⡟⠉⠁⠀⣹⢮⡹⡄⠀⠀
//⠀⠀⠀⠀⢹⡘⢼⠁⠀⠀⠀⠈⣷⠘⢦⢹⣧⢻⣽⡀⠀⠀⠻⠿⠚⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠳⠶⠾⠿⠇⠁⠀⣸⡟⣵⣿⠰⣹⡇⠀⠀⠀⡼⢂⣷⡵⡀⠀
//⠀⠀⠀⠀⠀⢏⡺⠀⠀⠀⠀⠀⠸⣍⢆⣻⢾⡹⣞⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡀⠀⡿⣞⡵⢾⣗⢰⡇⠀⢀⡼⢕⠣⡇⠱⣧⠀
//⠀⠀⠀⠀⠀⠘⡅⠀⠀⠀⠀⠀⠀⢸⡆⣿⢫⢷⣹⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⠤⢄⣀⢀⣀⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⢰⣟⢧⣻⢭⣿⡸⣇⠺⣍⠒⣍⠲⡅⠀⠘⠀
//⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⢸⡹⣼⣯⢳⢧⢿⡀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠁⢎⠰⡀⢆⠰⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣏⠿⣜⣳⢞⣿⡇⢣⠆⡍⢆⢣⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠰⣿⢏⡟⣮⢯⢹⣶⣄⡀⠀⠀⠀⠀⠀⠘⣧⠌⣂⠱⡈⢆⠩⣘⠆⠀⠀⠀⠀⠀⠀⣀⣴⣶⡿⣝⢯⣝⣮⣛⣿⣿⢠⢋⡜⡌⢆⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠱⣹⢾⡹⢧⢿⢸⣿⡾⣹⢟⣶⣤⣤⣀⡀⠈⠳⢄⠢⡁⢆⢡⠞⠀⠀⠀⣀⣤⢶⣞⡟⣿⢾⣻⡝⣺⢞⡶⣻⣳⡟⢤⠣⡜⣘⠲⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡴⡙⣮⢻⣝⡾⢸⣷⡿⣝⡾⠟⠾⠞⠷⠿⠻⢶⣦⡌⢭⠬⡁⠤⠐⢊⠉⢼⣟⣾⣼⣹⢻⣟⣳⢍⡿⣎⢷⣻⣗⣻⢆⠳⡘⢤⢋⠄⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡧⣉⣷⡻⣼⣹⡾⠗⠋⠀⠀⣈⠐⠄⣂⠰⢀⠂⠄⡙⠿⣒⣆⠄⣁⠂⠌⢼⣿⣳⣻⠽⣿⡿⢋⣼⡻⣼⢫⣿⡼⣽⡎⡱⣉⠦⣉⡆⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡗⢤⠹⣷⡽⠋⠀⠀⠀⡀⠰⢀⠊⠔⡀⠒⠤⢈⠔⡀⢂⠙⢦⠛⡲⡬⢀⠚⠻⢿⣫⢝⡿⢡⢫⡷⣝⡧⣟⡿⣜⣳⢿⡑⢤⠓⡤⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣏⠦⣉⡿⠁⠌⡑⠒⡈⠤⠁⡄⠌⡐⠠⢉⠐⡀⠆⡈⠤⠈⠌⣷⡌⣳⠄⡈⢤⡿⡜⣾⢡⢃⣿⢳⡝⡾⣽⡟⡽⣎⣿⡎⠦⣙⠰⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣳⠜⣼⠁⠌⡐⠠⡁⠰⢀⠡⠐⡐⠠⢁⠂⠰⠠⠘⣀⠂⢅⣒⣼⡙⡏⠀⢤⡿⢼⣹⡏⢦⣹⢷⣫⢽⡳⣟⣻⢿⣼⢞⣿⠰⣡⢃⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣯⣽⢾⠷⡈⠄⡡⠂⢁⢂⠁⢂⠡⢀⠑⠠⠌⢂⢁⠂⠤⢘⡎⠉⠹⡑⢿⡠⣼⡝⣣⡿⡘⢦⣟⢮⡳⢯⣽⠟⢁⡤⣚⢿⣾⡇⢆⠣⡆⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⢶⡟⠁⠀⣇⠌⠠⠑⡀⢊⠐⡄⠒⠈⠄⡡⠐⡈⠠⠘⣀⡞⠑⢄⠀⠘⡄⢻⡧⣝⣳⠣⣍⣟⡮⢯⣝⣯⣃⡴⢏⡾⠏⢁⡠⢿⣌⠣⣇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡟⠀⡴⠉⠘⡎⠠⠑⣀⠢⠁⠄⠡⠌⡐⠠⠑⣀⠢⠁⢤⣇⠀⠈⢣⠀⢙⡀⢻⣼⢏⠲⣼⡻⣼⢻⣜⡿⣣⡽⠋⢀⡴⢯⣹⣧⣿⡂⣯⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡚⠀⠎⠀⠀⢸⢁⠂⠅⡄⢂⠩⠐⡐⠂⠤⢁⠒⡀⠢⢁⡞⠀⢣⠀⠈⡅⠀⢃⠀⡿⣌⣽⡳⡽⣎⡷⡾⣽⠋⢀⡴⡟⢿⡧⠋⠀⢸⡃⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⢸⠀⠀⠀⣾⡳⣌⠐⢠⠁⠌⡁⠆⡉⠐⠂⡄⢁⢒⣤⡟⠀⠈⡀⠀⢸⠀⠘⠄⣻⢽⣞⣵⢻⡵⣻⠟⠁⡴⣏⣿⡽⠋⠀⠀⠀⠀⡇⡇⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣟⡆⠁⠀⠀⢸⠀⠙⠦⣽⠲⠬⣐⣀⡢⢐⣉⣰⣴⠾⠛⠋⢹⠀⠀⢇⠀⠀⠃⠀⢀⡽⣎⣿⢮⣗⣻⠋⣠⠾⡵⣹⠞⠀⠀⠀⠀⠀⢀⡇⣗⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣏⢷⡀⠀⠀⠸⡄⡁⠂⠌⠉⣷⣿⣿⣿⣿⣿⣿⣿⠛⠒⠒⠃⡇⠀⠘⠀⠀⠀⣠⢞⡳⢮⣽⢷⣺⢏⢴⣫⢳⡽⠃⠀⠀⠀⠀⠀⠀⢸⠆⡏⠤⠠⠠

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <memory>
#include <algorithm>
#include <unordered_map>

// Dev

#define debug std::cout<<"debug"<<std::endl;
#define pr std::cout<<ts.peek().value<<std::endl;

// Text styling

#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define ITALIC  "\033[3m"

#define PINK     "\033[38;5;174m"
#define FILENAME "\033[38;5;31m"
#define GRAY     "\033[38;5;240m"
#define ERROR    "\033[38;5;167m"
#define WARNING  "\033[38;5;228m"
#define LINECOL  "\033[38;5;228m"

// Spec

#define NAMESPACE_PUNCTUATION "::"   // Could also be .?
#define MEMBERSHIP_PUNCTUATION "."
#define INHERITANCE_PUNCTUATION ":"
#define DATATYPE_PUNCTUATION ":"
#define FUNCTION_VARIABLE_PUNCTUATION "<"
#define LAMBDA_PUNCTUATION "." // This is lambda calculus syntax, perhaps -> or => (tbi) is more readable?
#define CAST_OPERATOR "->"

#define POINTER_MODIFIER "?" // Might remove pointers altogether and just allow []
#define ENUM_ASSIGNMENT ":" // I might want it to be =

#define OVERLOAD_IDENTIFIER "op" // operator?
#define LAMBDA_IDENTIFIER ".Lambda"
#define CONSTRUCTOR_IDENTIFIER ".Constructor"
#define DESTRUCTOR_IDENTIFIER  ".Destructor"
#define LITERAL_IDENTIFIER "."

#define HALF_DATA_INDICATOR "h"
#define SINGLE_DATA_INDICATOR "f"
#define DOUBLE_DATA_INDICATOR "d"

#define KEYWORDS 40
std::string reserved[KEYWORDS] = {
    // Statements
    "if", "else", "switch", "case", "default", "loop", "while", "for", "do", "break", "continue", "return",
    // Keywords
    "var", "const", "fun", "virt", "union", "lambda", "type", "asm", "typeof", "sizeof", "new", "destroy", "namespace", "using", 
    // Data types
    "i8", "i16", "i32", "i64", "u8", "u16", "u32", "u64", "f16", "f32", "f64", "v",
    // Visiblity modifiers
    "private", "readonly"
};

std::unordered_map<char, char> escape = {
    {'a', '\a'},
    {'b', '\b'},
    {'e', '\e'},
    {'f', '\f'},
    {'n', '\n'},
    {'r', '\r'},
    {'t', '\t'},
    {'v', '\v'},
    {'\\','\\'}
};

enum Op {
    ADD, SUB, MUL, DIV, MOD,
    NOT, AND, OR, XOR,
    SHR, SHL,
    SETE, SETNE, SETG, SETNG, SETL, SETNL,
    LNOT, LAND, LOR, LXOR,
    INC, DEC, NEG, BOOL
};

enum TokenType {
    Keyword,
    Identifier,
    Integer,
    Floating,
    Operation,
    Punctuation,
    EoF
};

struct Token {
    TokenType type;
    std::string value;
    unsigned int line;
    unsigned int column;
};

// Global variables

std::string filename;
std::string sourceCode;

// Data type

struct DataType {
    enum Type {
        v,
        u8, u16, u32, u64,
        i8, i16, i32, i64,
        f16, f32, f64,
        fun, ptr,
        customtype, enumerator, generic,
        unresolved
    } type = i32;
    std::shared_ptr<DataType> pointerType;

    std::vector<DataType> functionParameters;
    std::shared_ptr<DataType> functionReturn;

    std::string customTypeName;

    std::string enumName;

    std::string genericName;

    std::string unresolvedName;
    std::string nmspc;

    // Debug purposes
    std::string format() {
        std::string out;
        switch (type) {
            case v: out   = "v"; break;
            case u8: out  = "u8"; break;
            case u16: out = "u16"; break;
            case u32: out = "u32"; break;
            case u64: out = "u64"; break;
            case i8: out  = "i8"; break;
            case i16: out = "i16"; break;
            case i32: out = "i32"; break;
            case i64: out = "i64"; break;
            case f16: out = "f16"; break;
            case f32: out = "f32"; break;
            case f64: out = "f64"; break;
            case ptr: out = "ptr"; break;
            case fun: out = "fun"; break;
            case generic: out = "gen"; break;
            case customtype: out = "custom"; break;
            case enumerator: out = "enum"; break;
        }
        if (type == ptr) {
            out += POINTER_MODIFIER + pointerType->format();
        } else if (type == fun) {
            out += DATATYPE_PUNCTUATION + functionReturn->format() + "<";
            for (auto par : functionParameters) {
                out += par.format() + ", ";
            }
            out += "\b\b>";
        } else if (type == generic) {
            out += ":" + genericName;
        } else if (type == customtype) {
            out += ":" + nmspc + "." + customTypeName;
        } else if (type == enumerator) {
            out += ":" + nmspc + "." + enumName;
        } else if (type == unresolved) {
            out += "unresolved: " + unresolvedName;
        }
        return out;
    }

    /*
    size_t size() {
        switch (type) {
            case u8: case i8:
                return 1;
            case u16: case i16: case f16:
                return 2;
            case u32: case i32: case f32:
                return 4;
            case u64: case i64: case f64:
                return 8;
            case fun: case ptr: case customtype:
                return 8;
            case generic: case v:
                return 0;
        }
    }
*/

    // Type matching
    bool operator==(DataType b) {
        if (type != b.type) return false;
        if (type == ptr && (*pointerType != *b.pointerType)) return false;
        if (type == fun) {
            if (*functionReturn != *b.functionReturn) return false;
            if (functionParameters.size() != b.functionParameters.size()) return false;
            for (int i = 0; i < functionParameters.size(); i++) {
                if (functionParameters[i] != b.functionParameters[i]) return false;
            }
        }
        if (type == customtype && ((customTypeName != b.customTypeName) || (nmspc != b.nmspc))) return false; // MKS is nominative. Also, // TODO: polymorphism
        if (type == enumerator && ((enumName != b.enumName) || (nmspc != b.nmspc))) return false;
        if (type == generic && (genericName != b.genericName)) return false;
        return true;
    }

    bool operator!=(DataType b) {
        return !(*this==b);
    }

    DataType() {};
    DataType(Type type) : type(type) {};
};

// Expressions

// Forward declaration

// Defining what is an expression and what isn't for the raw AST is actually really, really hard. Should Array be separate from Literal?

struct MemberExpression;        struct SubscriptExpression;     struct IdentifierExpression;

struct LiteralExpression;       struct ArrayExpression;         struct OperationExpression;     struct AssignmentExpression;        struct NewExpression;
struct LambdaExpression;        struct ConditionalExpression;   struct CastExpression;          struct FunctionCallExpression;      struct SizeofExpression;
struct TypeofExpression;

struct Expression {
    enum Type {
        LiteralExpressionT,
        ArrayExpressionT,
        IdentifierExpressionT,
        OperationExpressionT,
        AssignmentExpressionT,
        ConditionalExpressionT,
        CastExpressionT,
        NewExpressionT,
        LambdaExpressionT,
        MemberExpressionT,
        SubscriptExpressionT,
        FunctionCallExpressionT,
        SizeofExpressionT,
        TypeofExpressionT
    } type;

    DataType dataType;

    std::shared_ptr<LiteralExpression> literalExpression;
    std::shared_ptr<ArrayExpression> arrayExpression;
    std::shared_ptr<IdentifierExpression> identifierExpression;
    std::shared_ptr<OperationExpression> operationExpression;
    std::shared_ptr<AssignmentExpression> assignmentExpression;
    std::shared_ptr<ConditionalExpression> conditionalExpression;
    std::shared_ptr<CastExpression> castExpression;
    std::shared_ptr<NewExpression> newExpression;
    std::shared_ptr<LambdaExpression> lambdaExpression;
    std::shared_ptr<MemberExpression> memberExpression;
    std::shared_ptr<SubscriptExpression> subscriptExpression;
    std::shared_ptr<FunctionCallExpression> functionCallExpression;
    std::shared_ptr<SizeofExpression> sizeofExpression;
    std::shared_ptr<TypeofExpression> typeofExpression;

    Expression(std::shared_ptr<LiteralExpression> literalExpression) : type(LiteralExpressionT), literalExpression(literalExpression) {};
    Expression(std::shared_ptr<ArrayExpression> arrayExpression) : type(ArrayExpressionT), arrayExpression(arrayExpression) {};
    Expression(std::shared_ptr<IdentifierExpression> identifierExpression) : type(IdentifierExpressionT), identifierExpression(identifierExpression) {};
    Expression(std::shared_ptr<OperationExpression> operationExpression) : type(OperationExpressionT), operationExpression(operationExpression) {};
    Expression(std::shared_ptr<AssignmentExpression> assignmentExpression) : type(AssignmentExpressionT), assignmentExpression(assignmentExpression) {};
    Expression(std::shared_ptr<ConditionalExpression> conditionalExpression) : type(ConditionalExpressionT), conditionalExpression(conditionalExpression) {};
    Expression(std::shared_ptr<CastExpression> castExpression) : type(CastExpressionT), castExpression(castExpression) {};
    Expression(std::shared_ptr<NewExpression> newExpression) : type(NewExpressionT), newExpression(newExpression) {};
    Expression(std::shared_ptr<LambdaExpression> lambdaExpression) : type(LambdaExpressionT), lambdaExpression(lambdaExpression) {};
    Expression(std::shared_ptr<MemberExpression> memberExpression) : type(MemberExpressionT), memberExpression(memberExpression) {};
    Expression(std::shared_ptr<SubscriptExpression> subscriptExpression) : type(SubscriptExpressionT), subscriptExpression(subscriptExpression) {};
    Expression(std::shared_ptr<FunctionCallExpression> functionCallExpression) : type(FunctionCallExpressionT), functionCallExpression(functionCallExpression) {};
    Expression(std::shared_ptr<SizeofExpression> sizeofExpression) : type(SizeofExpressionT), sizeofExpression(sizeofExpression) {};
    Expression(std::shared_ptr<TypeofExpression> typeofExpression) : type(TypeofExpressionT), typeofExpression(typeofExpression) {};

    Expression() {};
};

struct LiteralExpression {
    enum Type {
        Integer,
        Half,
        Single, 
        Double,
    } type;

    union {
        uint64_t integer; // integers and chars (no sign extension anyway)
        uint16_t halfp;
        uint32_t singlep;
        uint64_t doublep;
    } lit;

    LiteralExpression() {};
    LiteralExpression(uint64_t integer) : type(Integer) {lit.integer = integer;};
    LiteralExpression(Type type) : type(type) {};
};

struct ArrayExpression {
    std::vector<Expression> array;

    ArrayExpression() {};
};

struct IdentifierExpression {
    std::string identifier;
    std::string nmspc;

    IdentifierExpression() {};
};

struct OperationExpression {
    Op op;
    Expression lhs;
    Expression rhs;

    OperationExpression() {};
};

struct AssignmentExpression {
    Expression lhs;
    Expression rhs;

    AssignmentExpression() {};
};

struct ConditionalExpression {
    Expression condition;
    Expression ifTrue;
    Expression ifFalse;
    bool ternary;

    ConditionalExpression() {};
};

struct CastExpression {
    Expression from;
    DataType to;

    CastExpression() {};
};

struct NewExpression {
    DataType dt;
    bool array;
    Expression size;
    std::vector<Expression> parameters;

    NewExpression() {};
};

struct LambdaExpression {
    std::vector<std::pair<std::string, DataType>> parameters;
    Expression body;

    LambdaExpression() {};
};

struct MemberExpression {
    Expression memberOf;
    std::string identifier;

    MemberExpression() {};
};

struct SubscriptExpression {
    Expression subscriptOf;
    Expression index;

    SubscriptExpression() {};
};

struct FunctionCallExpression {
    Expression function;
    std::vector<Expression> parameters;

    FunctionCallExpression() {};
};  

struct SizeofExpression {
    DataType dt;

    SizeofExpression() {};
};  

struct TypeofExpression {
    DataType dt;

    TypeofExpression() {};
};  

// Statements

// Forward declaration

struct CustomTypeDefinition;    struct FunctionDefinition;      struct VariableDefinition;      struct EnumDefinition;

struct BlockStatement;          struct IfStatement;             struct SwitchStatement;         struct LoopStatement;           struct WhileStatement;
struct ForStatement;            struct ReturnStatement;         struct DestroyStatement;        struct AssemblyStatement;


struct Statement {
    enum Type {
        CustomTypeDefinitionT,
        FunctionDefinitionT,
        VariableDefinitionT,
        EnumDefinitionT,

        BlockStatementT,
        IfStatementT,
        SwitchStatementT,
        LoopStatementT,
        WhileStatementT,
        ForStatementT,
        BreakStatementT,
        ContinueStatementT,
        ReturnStatementT,
        DestroyStatementT,
        AssemblyStatementT,

        ExpressionT
    } type;

    std::shared_ptr<CustomTypeDefinition> customTypeDefinition;
    std::shared_ptr<FunctionDefinition> functionDefinition;
    std::shared_ptr<VariableDefinition> variableDefinition;
    std::shared_ptr<EnumDefinition> enumDefinition;
    
    std::shared_ptr<BlockStatement> blockStatement;
    std::shared_ptr<IfStatement> ifStatement;
    std::shared_ptr<SwitchStatement> switchStatement;
    std::shared_ptr<LoopStatement> loopStatement;
    std::shared_ptr<WhileStatement> whileStatement;
    std::shared_ptr<ForStatement> forStatement;
    std::shared_ptr<ReturnStatement> returnStatement;
    std::shared_ptr<DestroyStatement> destroyStatement;
    std::shared_ptr<AssemblyStatement> assemblyStatement;

    std::shared_ptr<Expression> expression;

    Statement(std::shared_ptr<CustomTypeDefinition> customTypeDefinition) : customTypeDefinition(customTypeDefinition), type(CustomTypeDefinitionT) {};
    Statement(std::shared_ptr<FunctionDefinition> functionDefinition) : functionDefinition(functionDefinition), type(FunctionDefinitionT) {};
    Statement(std::shared_ptr<VariableDefinition> variableDefinition) : variableDefinition(variableDefinition), type(VariableDefinitionT) {};
    Statement(std::shared_ptr<EnumDefinition> enumDefinition) : enumDefinition(enumDefinition), type(EnumDefinitionT) {};
    
    Statement(std::shared_ptr<BlockStatement> blockStatement) : blockStatement(blockStatement), type(BlockStatementT) {};
    Statement(std::shared_ptr<IfStatement> ifStatement) : ifStatement(ifStatement), type(IfStatementT) {};
    Statement(std::shared_ptr<SwitchStatement> switchStatement) : switchStatement(switchStatement), type(SwitchStatementT) {};
    Statement(std::shared_ptr<LoopStatement> loopStatement) : loopStatement(loopStatement), type(LoopStatementT) {};
    Statement(std::shared_ptr<WhileStatement> whileStatement) : whileStatement(whileStatement), type(WhileStatementT) {};
    Statement(std::shared_ptr<ForStatement> forStatement) : forStatement(forStatement), type(ForStatementT) {};
    Statement(std::shared_ptr<ReturnStatement> returnStatement) : returnStatement(returnStatement), type(ReturnStatementT) {};
    Statement(std::shared_ptr<DestroyStatement> destroyStatement) : destroyStatement(destroyStatement), type(DestroyStatementT) {};
    Statement(std::shared_ptr<AssemblyStatement> assemblyStatement) : assemblyStatement(assemblyStatement), type(AssemblyStatementT) {};
    
    Statement(std::shared_ptr<Expression> expression) : expression(expression), type(ExpressionT) {};

    Statement(Type type) : type(type) {};
    Statement() {};
};

// Symbol definition

struct CustomTypeDefinition {
    std::string identifier;
    DataType parent;
    std::vector<std::pair<std::string, DataType>> attributes;
    bool alias;

    CustomTypeDefinition() {};
};

struct FunctionDefinition {
    std::string identifier;
    std::string membership;
    std::vector<std::string> generics;
    DataType returnType;
    std::vector<std::pair<std::string, DataType>> parameters;
    Statement body;

    FunctionDefinition() {};
};

struct VariableDefinition {
    std::string identifier;
    DataType type;

    VariableDefinition() {};
};

struct EnumDefinition {
    std::string identifier;
    std::unordered_map<std::string, int64_t> values;
    
    EnumDefinition() {};
};

// Actual statements

struct BlockStatement {
    std::vector<Statement> statements;

    BlockStatement() {};
};

struct IfStatement {
    Expression condition;
    Statement thenBranch;
    Statement elseBranch;
    bool hasElse;

    IfStatement() {};
};

struct SwitchStatement {
    Expression condition;

    SwitchStatement() {};
};

struct LoopStatement {
    Statement body;

    LoopStatement() {};
};

struct WhileStatement {
    Expression condition;
    Statement body;

    WhileStatement() {};
};

struct ForStatement {
    Statement init;
    Expression condition;
    Expression increment;
    Statement body;

    ForStatement() {};
};

struct ReturnStatement {
    Expression toReturn;

    ReturnStatement() {};
};

struct DestroyStatement {
    Expression toDestroy;

    DestroyStatement() {};
};

struct AssemblyStatement {
    std::string body;

    AssemblyStatement() {};
};

typedef std::vector<Statement> Ast;

// Debug (print expression and statement)

void printExpression(Expression exp, int indent) {
    switch (exp.type) {
        case Expression::LiteralExpressionT:
        {
            std::shared_ptr<LiteralExpression> x = exp.literalExpression;
            switch (x->type) {
                case LiteralExpression::Integer:
                    std::cout << std::string(indent, ' ') << "Integer literal: " << x->lit.integer << std::endl;
                    break;
                case LiteralExpression::Half:
                    std::cout << std::string(indent, ' ') << "Half literal: 0x" << std::hex << x->lit.halfp << std::endl;
                    break;
                case LiteralExpression::Single:
                    std::cout << std::string(indent, ' ') << "Single literal: 0x" << std::hex << x->lit.singlep << std::endl;
                    break;
                case LiteralExpression::Double:
                    std::cout << std::string(indent, ' ') << "Double literal: 0x" << std::hex << x->lit.doublep << std::endl;
                    break;
            }
            break;
        }
        case Expression::ArrayExpressionT:
        {
            std::shared_ptr<ArrayExpression> x = exp.arrayExpression;
            std::cout << std::string(indent, ' ') << "Array: " << std::endl;
            for (auto arr : x->array) {
                printExpression(arr, indent+4);
            }
            break;
        }
        case Expression::IdentifierExpressionT:
        {
            std::shared_ptr<IdentifierExpression> x = exp.identifierExpression;
            std::cout << std::string(indent, ' ') << "Identifier: " << x->nmspc << "." << x->identifier << std::endl;
            break;
        }
        case Expression::OperationExpressionT:
        {
            std::shared_ptr<OperationExpression> x = exp.operationExpression;
            std::cout << std::string(indent, ' ') << "Operation: " << x->op << std::endl;
            std::cout << std::string(indent+4, ' ') << "LHS: " << std::endl;
            printExpression(x->lhs, indent+8);
            if (!(x->op == Op::LNOT ||x->op == Op::NOT || x->op == Op::INC || x->op == Op::DEC ||  x->op == Op::NEG || x->op == Op::BOOL)) {
                std::cout << std::string(indent+4, ' ') << "RHS: " << std::endl;
                printExpression(x->rhs, indent+8);
            }
            break;
        }
        case Expression::AssignmentExpressionT:
        {
            std::shared_ptr<AssignmentExpression> x = exp.assignmentExpression;
            std::cout << std::string(indent, ' ') << "Assignment: " << std::endl;
            std::cout << std::string(indent+4, ' ') << "LHS: " << std::endl;
            printExpression(x->lhs, indent+8);
            std::cout << std::string(indent+4, ' ') << "RHS: " << std::endl;
            printExpression(x->rhs, indent+8);
            break;
        }
        
        case Expression::ConditionalExpressionT:
        {
            std::shared_ptr<ConditionalExpression> x = exp.conditionalExpression;
            std::cout << std::string(indent, ' ') << "Conditional operation: " << std::endl;
            std::cout << std::string(indent+4, ' ') << "Condition: " << std::endl;
            printExpression(x->condition, indent+8);
            if (x->ternary) {
                std::cout << std::string(indent+4, ' ') << "If true: " << std::endl;
                printExpression(x->ifTrue, indent+8);
                std::cout << std::string(indent+4, ' ') << "If false: " << std::endl;
                printExpression(x->ifFalse, indent+8);
            } else {
                std::cout << std::string(indent+4, ' ') << "If false: " << std::endl;
                printExpression(x->ifFalse, indent+8);
            }
            break;
        }
        case Expression::CastExpressionT:
        {
            std::shared_ptr<CastExpression> x = exp.castExpression;
            std::cout << std::string(indent, ' ') << "Cast: " << std::endl;
            std::cout << std::string(indent+4, ' ') << "From: " << std::endl;
            printExpression(x->from, indent+8);
            std::cout << std::string(indent+4, ' ') << "To: " << x->to.format() << std::endl;
            break;
        }
        case Expression::NewExpressionT:
        {
            std::shared_ptr<NewExpression> x = exp.newExpression;
            std::cout << std::string(indent, ' ') << "New: " << x->dt.format() << std::endl;
            if (x->array) {
                std::cout << std::string(indent+4, ' ') << "Size: " << std::endl;
                printExpression(x->size, indent+8);
            } else {
                std::cout << std::string(indent+4, ' ') << "Arguments: " << std::endl;
                for (auto arg : x->parameters) {
                    printExpression(arg, indent+8);
                }
            }
            break;
        }
        case Expression::LambdaExpressionT:
        {
            std::shared_ptr<LambdaExpression> x = exp.lambdaExpression;
            std::cout << std::string(indent, ' ') << "Lambda: " << std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Parameters: "<<std::endl;
            for (auto x : x->parameters) {
                std::cout<<std::string(indent+8, ' ')<<x.first<<" -> "<<x.second.format()<<std::endl;
            }
            std::cout<<std::string(indent+4, ' ')<<"Body: "<<std::endl;
            printExpression(x->body, indent+8);
            break;
        }
        case Expression::MemberExpressionT:
        {
            std::shared_ptr<MemberExpression> x = exp.memberExpression;
            std::cout << std::string(indent, ' ') << "Member: " << x->identifier << std::endl;
            std::cout << std::string(indent+4, ' ') << "Of: " << std::endl;
            printExpression(x->memberOf, indent+8);
            break;
        }
        case Expression::SubscriptExpressionT:
        {
            std::shared_ptr<SubscriptExpression> x = exp.subscriptExpression;
            std::cout << std::string(indent, ' ') << "Subscript: " << std::endl;
            std::cout << std::string(indent+4, ' ') << "Index: " << std::endl;
            printExpression(x->index, indent+8);
            std::cout << std::string(indent+4, ' ') << "Of: " << std::endl;
            printExpression(x->subscriptOf, indent+8);
            break;
        }
        case Expression::FunctionCallExpressionT:
        {
            std::shared_ptr<FunctionCallExpression> x = exp.functionCallExpression;
            std::cout << std::string(indent, ' ') << "Function call: " << std::endl;
            std::cout << std::string(indent+4, ' ') << "Function: " << std::endl;
            printExpression(x->function, indent+8);
            std::cout << std::string(indent+4, ' ') << "Arguments: " << std::endl;
            for (auto arg : x->parameters) {
                printExpression(arg, indent+8);
            }
            break;
        }
    }
}

void printStatement(Statement stmt, int indent) {
    switch (stmt.type) {
        case Statement::CustomTypeDefinitionT:
        {
            std::cout<<std::string(indent, ' ')<<"Custom type definition: "<<stmt.customTypeDefinition->identifier<<std::endl;
            if (stmt.customTypeDefinition->alias) {
                std::cout<<std::string(indent+4, ' ')<<"Alias for: "<<stmt.customTypeDefinition->parent.format()<<std::endl;
            } else {
                std::cout<<std::string(indent+4, ' ')<<"Parent: "<<stmt.customTypeDefinition->parent.format()<<std::endl;
                std::cout<<std::string(indent+4, ' ')<<"Attributes: "<<std::endl;
                for (auto x : stmt.customTypeDefinition->attributes) {
                    std::cout<<std::string(indent+8, ' ')<<x.first<<" -> "<<x.second.format()<<std::endl;
                }
            }
            break;
        }
        case Statement::FunctionDefinitionT: {
            std::cout<<std::string(indent, ' ')<<"Function definition: "<<stmt.functionDefinition->identifier<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Member of: "<<stmt.functionDefinition->membership<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Return type: "<<stmt.functionDefinition->returnType.format()<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Generics: ";
            for (auto x : stmt.functionDefinition->generics) {
                std::cout<<std::string(indent+8, ' ')<<x<<" ";
            }
            std::cout<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Parameters: "<<std::endl;
            for (auto x : stmt.functionDefinition->parameters) {
                std::cout<<std::string(indent+8, ' ')<<x.first<<" -> "<<x.second.format()<<std::endl;
            }
            std::cout<<std::string(indent+4, ' ')<<"Body: "<<std::endl;
            printStatement(stmt.functionDefinition->body, indent+8);
            break;
        }
        case Statement::VariableDefinitionT: {
            std::cout<<std::string(indent, ' ')<<"Variable definition: "<<stmt.variableDefinition->identifier<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Type: "<<stmt.variableDefinition->type.format()<<std::endl;
            break;
        }
        case Statement::EnumDefinitionT: {
            std::cout<<std::string(indent, ' ')<<"Enum definition: "<<stmt.enumDefinition->identifier<<std::endl;
            for (auto x : stmt.enumDefinition->values) {
                std::cout<<std::string(indent+4, ' ')<<x.first<<" -> "<<x.second<<std::endl;
            }
            break;
        }
        case Statement::BlockStatementT: {
            std::cout<<std::string(indent, ' ')<<"Block: "<<std::endl;
            for (auto x : stmt.blockStatement->statements) {
                printStatement(x, indent+4);
            }
            break;
        }
        case Statement::IfStatementT: {
            std::cout<<std::string(indent, ' ')<<"If statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Condition: "<<std::endl;
            printExpression(stmt.ifStatement->condition, indent+8);
            std::cout<<std::string(indent+4, ' ')<<"Then branch: "<<std::endl;
            printStatement(stmt.ifStatement->thenBranch, indent+8);
            if (stmt.ifStatement->hasElse) {
                std::cout<<std::string(indent+4, ' ')<<"Else branch: "<<std::endl;
                printStatement(stmt.ifStatement->elseBranch, indent+8);
            }
            break;
        }
        case Statement::SwitchStatementT: {
            std::cout<<std::string(indent, ' ')<<"Switch statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Condition: "<<std::endl;
            printExpression(stmt.switchStatement->condition, indent+8);
            break;
        }
        case Statement::LoopStatementT: {
            std::cout<<std::string(indent, ' ')<<"Loop statement: "<<std::endl;
            printStatement(stmt.loopStatement->body, indent+4);
            break;
        }
        case Statement::WhileStatementT: {
            std::cout<<std::string(indent, ' ')<<"While statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Condition: "<<std::endl;
            printExpression(stmt.whileStatement->condition, indent+8);
            printStatement(stmt.whileStatement->body, indent+4);
            break;
        }
        case Statement::ForStatementT: {
            std::cout<<std::string(indent, ' ')<<"For statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Init: "<<std::endl; 
            printStatement(stmt.forStatement->init, indent+8);
            std::cout<<std::string(indent+4, ' ')<<"Condition: "<<std::endl;
            printExpression(stmt.forStatement->condition, indent+8);
            std::cout<<std::string(indent+4, ' ')<<"Increment: "<<std::endl;
            printExpression(stmt.forStatement->increment, indent+8);
            std::cout<<std::string(indent+4, ' ')<<"Body: "<<std::endl;
            printStatement(stmt.forStatement->body, indent+8);
            break;
        }
        case Statement::ReturnStatementT: {
            std::cout<<std::string(indent, ' ')<<"Return statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"To return: "<<std::endl;
            printExpression(stmt.returnStatement->toReturn, indent+8);
            break;
        }
        case Statement::DestroyStatementT: {
            std::cout<<std::string(indent, ' ')<<"Destroy statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"To destroy: "<<std::endl;
            printExpression(stmt.destroyStatement->toDestroy, indent+8);
            break;
        }
        case Statement::AssemblyStatementT: {
            std::cout<<std::string(indent, ' ')<<"Assembly statement: "<<std::endl;
            std::cout<<std::string(indent+4, ' ')<<"Body: "<<std::endl;
            std::cout<<std::string(indent+8, ' ')<<stmt.assemblyStatement->body<<std::endl;
            break;
        }
        case Statement::ExpressionT: {
            std::cout<<std::string(indent, ' ')<<"Expression: "<<std::endl;
            printExpression(*stmt.expression, indent+8);
            break;
        }
    }
}

// Tiny half precision float library

static uint16_t floatToHalf(float f) {
    uint32_t fb = *reinterpret_cast<uint32_t*>(&f);
    uint32_t sign = (fb >> 31) & 0x1;
    uint32_t exponent = (fb >> 23) & 0xFF;
    uint32_t fraction = fb & 0x7FFFFF;

    if (exponent == 255) {
        return (sign << 15) | (0x1F << 10) | (fraction ? 0x200 : 0);
    } else if (exponent > 142) {
        return (sign << 15) | (0x1F << 10);
    } else if (exponent < 113) {
        return (sign << 15);
    }

    exponent -= 112;

    fraction >>= 13;
    return (sign << 15) | (exponent << 10) | fraction;
}

static float halfToFloat(uint16_t h) {
    uint32_t sign = (h >> 15) & 0x1;
    uint32_t exponent = (h >> 10) & 0x1F;
    uint32_t fraction = h & 0x3FF;

    if (exponent == 31) {
        return (sign ? -1.0f : 1.0f) * std::numeric_limits<float>::infinity();
    } else if (exponent == 0) {
        return sign ? -0.0f : 0.0f;
    }

    exponent += 112;

    fraction <<= 13;
    uint32_t fb = (sign << 31) | (exponent << 23) | fraction;

    return *reinterpret_cast<float*>(&fb);
}

// Error handling

enum ErrorType {
    NoInputFiles,
    FileNotFound,

    UnmatchedPunctuation,
    UnexpectedEOF,
    UnexpectedToken
};

void error(ErrorType err, Token token) {
    if (err == NoInputFiles) {
        std::cerr<<PINK ITALIC BOLD<<"bloom"<<RESET<<" | "<<BOLD ERROR<<"! fatal error: "<<RESET;
    } else {
        std::cerr<<PINK ITALIC BOLD<<"bloom"<<RESET<<" | "<<FILENAME BOLD ITALIC<<filename<<RESET<<" at "<<LINECOL BOLD<<token.line+1<<":"<<token.column+1<<ERROR<<" ! fatal error: "<<RESET;
    }

    switch (err) {
        case NoInputFiles:
            std::cerr << "no input files" << std::endl;
            exit(1);
        case FileNotFound:
            std::cerr << "file not found: " << ITALIC BOLD << token.value << RESET << std::endl;
            exit(1);
        case UnmatchedPunctuation:
            std::cerr << "unmatched punctuation: " << token.value << std::endl;
            break;
        case UnexpectedEOF:
            std::cerr << "unexpected end of file: " << token.value << std::endl;
            break;
        case UnexpectedToken:
            std::cerr << "unexpected token: " << token.value << std::endl;
            break;
    }
    std::istringstream stream(sourceCode);
    std::string s;
    for (int i = 0; i <= token.line; i++) {
        std::getline(stream, s);
    }
    std::cerr<<BOLD LINECOL<<std::setw(5)<<token.line+1<<RESET<<" | "<<s<<std::endl;
    exit(1);
}

// TokenStream

class TokenStream {
    public:
        virtual ~TokenStream() = default;  
        virtual Token next() const = 0;
        virtual Token peek() const = 0;
        virtual bool  eof()  const = 0;

        void assert(std::string token) const {
            if (peek().value != token) error(UnexpectedToken, peek());
            next();
        }
};

class BufferedTokenStream : public TokenStream {
    private: 
        const std::vector<Token> tokens;
        mutable uint64_t pos = 0;
    public:
        Token next() const { return tokens[pos++]; }
        Token peek() const { return tokens[pos]; }
        bool  eof()  const { return pos >= tokens.size(); }

        BufferedTokenStream(const std::vector<Token> tokens) : tokens(tokens) {};
};

// Parser

class Parser {
    public:
        Parser(const TokenStream& ts) : ts(ts), scope(0), scopeTree({0}) {}
        Ast parse() {
            Ast ast;

            while (!ts.eof()) {
                ast.push_back(parseObject());
            }

            return ast;
        }
    private:
        const TokenStream& ts;
        uint64_t scope;
        std::vector<unsigned int> scopeTree;

        // Parses the namespace
        std::pair<std::string, std::string> parseNamespace() {
            std::string nmspc = "*";
            std::string id = ts.next().value;

            if (ts.peek().value == NAMESPACE_PUNCTUATION) {
                nmspc = id;
                id = ts.next().value; 
            }
            
            return {nmspc, id};
        }

        // Parses a data type
        DataType parseDataType() {
            DataType ret;
            
            if (ts.peek().type == TokenType::Identifier) {
                ret.type = DataType::unresolved;
                std::pair<std::string, std::string> p = parseNamespace();
                ret.nmspc = p.first;
                ret.unresolvedName = p.second;
            } else {
                if (ts.peek().value == "v") ret.type  = DataType::v;
                else if (ts.peek().value == "u8") ret.type  = DataType::u8;
                else if (ts.peek().value == "u16") ret.type = DataType::u16;
                else if (ts.peek().value == "u32") ret.type = DataType::u32;
                else if (ts.peek().value == "u64") ret.type = DataType::u64;
                else if (ts.peek().value == "i8") ret.type  = DataType::i8;
                else if (ts.peek().value == "i16") ret.type = DataType::i16;
                else if (ts.peek().value == "i32") ret.type = DataType::i32;
                else if (ts.peek().value == "i64") ret.type = DataType::i64;
                else if (ts.peek().value == "f16") ret.type = DataType::f16;
                else if (ts.peek().value == "f32") ret.type = DataType::f32;
                else if (ts.peek().value == "f64") ret.type = DataType::f64;
                ts.next(); // Skip self
            }
            
            // Handle modifiers
            while (ts.peek().value == POINTER_MODIFIER || ts.peek().value == "<" || ts.peek().value == "[") {
                std::shared_ptr<DataType> subtype = std::make_shared<DataType>(ret);
                if (ts.peek().value == POINTER_MODIFIER) {
                    ret = DataType(DataType::ptr);
                    ret.pointerType = subtype;
                    ts.next(); // Skip pointer modifier
                } else if (ts.peek().value == "[") {
                    ret = DataType(DataType::ptr);
                    ret.pointerType = subtype;
                    ts.next(); // Skip "["
                    ts.assert("]");
                } else if (ts.peek().value == FUNCTION_VARIABLE_PUNCTUATION) {
                    ret = DataType(DataType::fun);
                    ret.functionReturn = subtype;
                    ts.next(); // Skip "<"
                    while (!ts.eof() && ts.peek().value != ">") {
                        ret.functionParameters.push_back(parseDataType());
                        if (ts.peek().value == ",") ts.next(); // Skip ","
                        else if (ts.peek().value != ">") error(UnexpectedToken, ts.peek());
                    }
                    ts.next(); // Skip ">"
                } 
            }

            return ret;
            return ret;
        }

        // Parses an object
        Statement parseObject() {
            if (ts.peek().value == "var" ||
                ts.peek().value == "const")               return defineVariable();
            if (ts.peek().value == "fun" ||
                ts.peek().value == "virt")                return defineFunction(); // Eventually, get rid of the "virt" and make it guess it. At least for children.
            else if (ts.peek().value == "type")           return defineType();
            else if (ts.peek().value == "enum")           return defineEnum();
            else if (ts.peek().value == "namespace")      return defineNamespace();
            //else if (ts.peek().value == "using")          return parseUsing(); // TODO (during linking, after translation is over)
        }
        
        // Parses a variable definition
        Statement defineVariable() {
            std::shared_ptr<VariableDefinition> ret = std::make_shared<VariableDefinition>();
            bool constant = ts.next().value == "const";
            ret->identifier = ts.next().value;
            
            if (ts.peek().value == DATATYPE_PUNCTUATION) {
                ts.next(); // Skip datatype punctuation
                ret->type = parseDataType();
            } else if (ts.peek().value == "=") {
                // TODO: Infer (auto). For now, assume i64. Maybe, set a flag that says if it has to be inferred, and then do that during semantic analysis?
                ret->type = DataType(DataType::i64);
            }

            if (ts.peek().value == "=") {
                std::shared_ptr<AssignmentExpression> ass = std::make_shared<AssignmentExpression>();
                ts.next();
                std::shared_ptr<IdentifierExpression> id = std::make_shared<IdentifierExpression>();
                id->identifier = ret->identifier;
                ass->lhs = id;
                ass->rhs = parseExpression();

                std::shared_ptr<BlockStatement> block = std::make_shared<BlockStatement>();
                block->statements.push_back(ret);
                block->statements.push_back(std::make_shared<Expression>(ass));
                ts.assert(";");
                return block;
            }

            // TODO: Scopes

            ts.assert(";");
            
            return ret;
        }
        
        // Parses a function definition
        Statement defineFunction() {
            std::shared_ptr<FunctionDefinition> ret = std::make_shared<FunctionDefinition>();
            bool virt = ts.next().value == "virt"; // TODO: do something with this information
            ret->identifier = ts.next().value;

            // Check if function is a member (?) or if it has generics
            if (ts.peek().value == MEMBERSHIP_PUNCTUATION) {
                ts.next(); // Skip membership punctuation
                ret->membership = ret->identifier;
                ret->identifier = ts.next().value;
            } else if (ts.peek().value == "<") {
                ts.next();
            }

            // Parse return type of function (void if omitted)
            if (ts.peek().value == DATATYPE_PUNCTUATION) {
                ts.next(); // Skip datatype punctuation
                ret->returnType = parseDataType();
            } else {
                ret->returnType = DataType(DataType::v);
            }
            
            ts.assert("(");
            while (!ts.eof() && ts.peek().value != ")") {
                std::string identifier = ts.next().value;
                ts.assert(DATATYPE_PUNCTUATION);
                ret->parameters.push_back({identifier, parseDataType()});
                if (ts.peek().value == ",") ts.next();
                else if (ts.peek().value != ")") error(UnexpectedToken, ts.peek());
            }
            ts.assert(")");
            
            ret->body = parseStatement();
            
            return ret;
        }

        // Parses a type definition
        Statement defineType() {
            std::shared_ptr<CustomTypeDefinition> ret = std::make_shared<CustomTypeDefinition>();
            ts.next(); // Skip "type"
            ret->identifier = ts.next().value;

            if (ts.peek().value == INHERITANCE_PUNCTUATION) {
                ts.next(); // Skip inheritance punctuation
                ret->parent = parseDataType();
            }

            // TODO: .TypeHash, .ParentHash, .TypeName?, .VTable

            if (ts.peek().value == "(") {
                ts.next();
                while (!ts.eof() && ts.peek().value != ")") {
                    std::string identifier = ts.next().value;
                    ts.assert(DATATYPE_PUNCTUATION);
                    ret->attributes.push_back({identifier, parseDataType()});
                    if (ts.peek().value == ",") ts.next();
                    else if (ts.peek().value != ")") error(UnexpectedToken, ts.peek());
                }
                ts.assert(")");
                ret->alias = false;
            } else {
                ret->alias = true;
            }

            ts.assert(";");
            
            return ret;
        }

        // Parses an enumerator definition
        Statement defineEnum() {
            std::shared_ptr<EnumDefinition> ret = std::make_shared<EnumDefinition>();
            ts.next(); // Skip "enum"
            ret->identifier = ts.next().value;

            int64_t maxVal = 0;
            ts.assert("(");
            while (!ts.eof() && ts.peek().value != ")") {
                std::string identifier = ts.next().value;
                if (ts.peek().value == ENUM_ASSIGNMENT) {
                    ts.next(); // Skip enum assignment punctuation
                    if (ts.peek().type != Integer) error(UnexpectedToken, ts.peek());
                    int64_t val = std::stoi(ts.next().value);
                    if (val > maxVal) maxVal = val + 1;
                    ret->values[identifier] = val;
                } else {
                    ret->values[identifier] = maxVal++;
                }
                
                if (ts.peek().value == ",") ts.next();
                else if (ts.peek().value != ")") error(UnexpectedToken, ts.peek());
            }
            ts.assert(")");

            ts.assert(";");
            
            return ret;
        }

        // Parses a namespace ts.assertion
        Statement defineNamespace() {
            
        }

        // Parses a statement
        Statement parseStatement() {
            if      (ts.peek().value == "if")         return parseIfStatement();
            else if (ts.peek().value == "switch")     return parseSwitchStatement();
            else if (ts.peek().value == "loop")       return parseLoopStatement();
            else if (ts.peek().value == "while" ||
                     ts.peek().value == "do")         return parseWhileStatement();
            else if (ts.peek().value == "for")        return parseForStatement();
            else if (ts.peek().value == "{")          return parseBlockStatement();
            else if (ts.peek().value == "return")     return parseReturnStatement();
            else if (ts.peek().value == "break")      return Statement(Statement::BreakStatementT);
            else if (ts.peek().value == "continue")   return Statement(Statement::ContinueStatementT);
            else if (ts.peek().value == "asm")        return parseAssemblyStatement(); // TODO: recognize opcodes and execute them automatically
            else if (ts.peek().value == "destroy")    return parseDestroyStatement();
            else if (ts.peek().value == "var")        return defineVariable();
            else if (ts.peek().value == ";")          {ts.next(); return Statement();}
            else if (ts.peek().type == EoF)           error(UnexpectedEOF, ts.next());
            else {Expression exp = parseExpression(); ts.assert(";"); return std::make_shared<Expression>(exp);}
        }

        // Parses an if statement
        Statement parseIfStatement() {
            std::shared_ptr<IfStatement> ret = std::make_shared<IfStatement>();
            ts.next(); // Skip "if"

            ts.assert("(");
            ret->condition = parseExpression();
            ts.assert(")");

            ret->thenBranch = parseStatement();

            if (ts.peek().value == "else") {
                ret->elseBranch = parseStatement();
                ret->hasElse = true;
            } else {
                ret->hasElse = false;
            }

            return ret;
        }

        // Parses a switch statement
        Statement parseSwitchStatement() {
            std::shared_ptr<SwitchStatement> ret = std::make_shared<SwitchStatement>();

            ts.assert("(");
            ret->condition = parseExpression();
            ts.assert(")");

            return ret;
        }

        // Parses a loop statement (Rust-like)
        Statement parseLoopStatement() {
            std::shared_ptr<LoopStatement> ret = std::make_shared<LoopStatement>();
            ts.next(); // Skip "loop"

            ret->body = parseStatement();

            return ret;
        }

        // Parses a while statement
        Statement parseWhileStatement() {
            std::shared_ptr<WhileStatement> ret = std::make_shared<WhileStatement>();
            if (ts.next().value == "do") {
                ret->body = parseStatement();
                
                ts.assert("while");
                ts.assert("(");
                ret->condition = parseExpression();
                ts.assert(")");

                ts.assert(";");
            } else {
                ts.assert("(");
                ret->condition = parseExpression();
                ts.assert(")");

                ret->body = parseStatement();
            }

            return ret;
        }

        // Parses a for statement
        Statement parseForStatement() {
            std::shared_ptr<ForStatement> ret = std::make_shared<ForStatement>();
            ts.next(); // Skip "for"

            ts.assert("(");
            ret->init = parseStatement();
            
            ret->condition = parseExpression();
            ts.assert(";");

            ret->increment = parseExpression();
            ts.assert(")");

            ret->body = parseStatement();

            return ret; 
        }

        // Parses a code block (delimited by curly brackets)
        Statement parseBlockStatement() {
            std::shared_ptr<BlockStatement> ret = std::make_shared<BlockStatement>();
            
            ts.next(); // Skip "{"
            while (!ts.eof() && ts.peek().value != "}") {
                ret->statements.push_back(parseStatement());
            }
            ts.assert("}");

            return ret;
        }

        // Parses a return statement
        Statement parseReturnStatement() {
            std::shared_ptr<ReturnStatement> ret = std::make_shared<ReturnStatement>();

            ret->toReturn = parseExpression();
            
            ts.assert(";");
            return ret;
        }

        // Parses a destroy statement
        Statement parseDestroyStatement() {
            std::shared_ptr<DestroyStatement> ret = std::make_shared<DestroyStatement>();

            ret->toDestroy = parseExpression();

            ts.assert(";");
            return ret;
        }

        // Parses an assembly statement
        Statement parseAssemblyStatement() {
            std::shared_ptr<AssemblyStatement> ret = std::make_shared<AssemblyStatement>();
            ts.next(); // Skip "asm"

            // TODO: logic. might want to fix lexer for this.

            return ret;
        }

        // Parses an expression
        std::vector<std::shared_ptr<Expression>> expStack;
        uint8_t precedence = 0;

        Expression parseExpression() {
            while (!ts.eof() && ts.peek().value != ";" && ts.peek().value != ")" && ts.peek().value != "," && ts.peek().value != "]" && ts.peek().value != "}" && ts.peek().value != ":") {\
                if      (ts.peek().type == Integer)             parseInteger();
                else if (ts.peek().type == Floating)            parseFloating();
                else if (ts.peek().type == Identifier)          parseIdentifier();
                
                else if (expStack.size() == 0 &&
                        ts.peek().value == "[")                 parseArray();
                        
                else if (expStack.size() == 0 &&
                        ts.peek().value == "(")                 {ts.next(); expStack.push_back(std::make_shared<Expression>(parseExpression())); ts.assert(")");}

                else if (ts.peek().type == TokenType::Operation ||
                        ts.peek().value == "(")                 {if (parseOperation()) break;}
                
                else if (ts.peek().value == "lambda")           parseLambda();
                else if (ts.peek().value == "new")              parseNew();
                else if (ts.peek().value == "sizeof")           parseSizeof();
                else if (ts.peek().value == "typeof")           parseTypeof(); // ?
            }
            Expression ret = *expStack.back();
            expStack.pop_back();
            return ret;
        }

        // Parses an integer literal
        void parseInteger() {
            std::shared_ptr<LiteralExpression> ret = std::make_shared<LiteralExpression>(std::stol(ts.next().value));
            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses a floating point literal
        void parseFloating() {
            std::shared_ptr<LiteralExpression> ret;
            std::string lit = ts.next().value;

            if (ts.peek().value == DOUBLE_DATA_INDICATOR) {
                ret = std::make_shared<LiteralExpression>(LiteralExpression::Double);
                double d = std::stod(lit);
                uint64_t integer = *(uint64_t*)&d;
                ret->lit.doublep = integer;
                ts.next();
            } else if (ts.peek().value == SINGLE_DATA_INDICATOR) {
                ret = std::make_shared<LiteralExpression>(LiteralExpression::Single);
                float f = std::stof(lit);
                uint32_t integer = *(uint32_t*)&f;
                ret->lit.singlep = integer;
                ts.next();
            } else if (ts.peek().value == HALF_DATA_INDICATOR) {
                ret = std::make_shared<LiteralExpression>(LiteralExpression::Half);
                float f = std::stof(lit);
                ret->lit.halfp = floatToHalf(f);
                ts.next();
            } else {
                // If nothing is specified, double is assumed
                ret = std::make_shared<LiteralExpression>(LiteralExpression::Double);
                double d = std::stod(lit);
                uint64_t integer = *(uint64_t*)&d;
                ret->lit.doublep = integer;
            }

            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses an identifier
        void parseIdentifier() {
            std::shared_ptr<IdentifierExpression> ret = std::make_shared<IdentifierExpression>();
            std::pair<std::string, std::string> p = parseNamespace();
            ret->nmspc = p.first;
            ret->identifier = p.second;
            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses an array
        void parseArray() {
            std::shared_ptr<ArrayExpression> ret = std::make_shared<ArrayExpression>();
            ts.next();
            while (!ts.eof() && ts.peek().value != "]") {
                ret->array.push_back(parseExpression());
                if (ts.peek().value == ",") ts.next();
                else if (ts.peek().value != "]") error(UnexpectedToken, ts.peek());
            }
            ts.assert("]");

            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses a lambda function
        void parseLambda() {
            std::shared_ptr<LambdaExpression> ret = std::make_shared<LambdaExpression>();
            ts.next();
            
            ts.assert("(");
            while (!ts.eof() && ts.peek().value != ")") {
                std::string identifier = ts.next().value;
                ts.assert(DATATYPE_PUNCTUATION);
                ret->parameters.push_back({identifier, parseDataType()});
                if (ts.peek().value == ",") ts.next();
                else if (ts.peek().value != ")") error(UnexpectedToken, ts.peek());
            }
            ts.assert(")");

            ts.assert(LAMBDA_PUNCTUATION);
            
            ts.assert("{");
            ret->body = parseExpression();
            ts.assert("}");
            

            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses a new call
        void parseNew() {
            std::shared_ptr<NewExpression> ret = std::make_shared<NewExpression>();
            ts.next();
            ret->dt = parseDataType();

            if (ts.peek().value == "(") {
                ts.next();
                ret->array = false;
                while (!ts.eof() && ts.peek().value != ")") {
                    ret->parameters.push_back(parseExpression());
                    if (ts.peek().value == ",") ts.next();
                    else if (ts.peek().value != ")") error(UnexpectedToken, ts.peek());
                }
                ts.assert(")");
            } else if (ts.peek().value == "[") {
                ts.next();
                ret->array = true;

                ret->size = parseExpression();
                ts.assert("]");
            } else {
                error(UnexpectedToken, ts.peek());
            }

            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses a sizeof call
        void parseSizeof() {
            std::shared_ptr<SizeofExpression> ret = std::make_shared<SizeofExpression>();
            ts.next();
            ret->dt = parseDataType();
            
            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses a typeof call
        void parseTypeof() {
            std::shared_ptr<TypeofExpression> ret = std::make_shared<TypeofExpression>();
            ts.next();
            ret->dt = parseDataType();
            
            expStack.push_back(std::make_shared<Expression>(ret));
        }

        // Parses an operation
        bool parseOperation() {
            std::string op = ts.peek().value;
            if (op == "!") {
                ts.next();
                UnaryOperation(Op::LNOT);
                return false;
            } else if (op == "~") {
                ts.next();
                UnaryOperation(Op::NOT);
                return false;
            } else if (op == "-") {
                ts.next();
                UnaryOperation(Op::NEG);
                return false;
            } else if (op == "?" && expStack.size() == 0) { // maybe?
                ts.next();
                UnaryOperation(Op::BOOL);
                return false;
            }
            
            if (expStack.size() == 0) error(UnexpectedToken, ts.peek());

            if (op == "=") {
                // Assignment
                std::shared_ptr<AssignmentExpression> ret = std::make_shared<AssignmentExpression>();
                ts.next();
                ret->lhs = *expStack.back();
                expStack.pop_back();
                ret->rhs = parseExpression();

                expStack.push_back(std::make_shared<Expression>(ret));
            } else if (ts.peek().value == "=") {
                ts.next(); ts.next();
                AugmentedAssignment(op);
            } else if (op == ".") {
                // Member
                std::shared_ptr<MemberExpression> ret = std::make_shared<MemberExpression>();
                ts.next();
                ret->memberOf = *expStack.back();
                expStack.pop_back();
                ret->identifier = ts.next().value;

                expStack.push_back(std::make_shared<Expression>(ret));
            } else if (op == "[") {
                // Subscript
                std::shared_ptr<SubscriptExpression> ret = std::make_shared<SubscriptExpression>();
                ts.next();
                ret->subscriptOf = *expStack.back();
                expStack.pop_back();
                ret->index = parseExpression();
                ts.assert("]");

                expStack.push_back(std::make_shared<Expression>(ret));
            } else if (op == "(") {
                // Function call
                std::shared_ptr<FunctionCallExpression> ret = std::make_shared<FunctionCallExpression>();
                ts.next();
                ret->function = *expStack.back();
                expStack.pop_back();

                while (!ts.eof() && ts.peek().value != ")") {
                    ret->parameters.push_back(parseExpression());
                    if (ts.peek().value == ",") ts.next();
                    else if (ts.peek().value != ")") error(UnexpectedToken, ts.peek());
                }
                ts.assert(")");

                expStack.push_back(std::make_shared<Expression>(ret));
            } else if (op == CAST_OPERATOR) {
                // Cast
                std::shared_ptr<CastExpression> ret = std::make_shared<CastExpression>();
                ts.next();
                ret->from = *expStack.back();
                expStack.pop_back();
                ret->to = parseDataType();

                expStack.push_back(std::make_shared<Expression>(ret));
            } else if (op == "?") {
                // Ternary
                std::shared_ptr<ConditionalExpression> ret = std::make_shared<ConditionalExpression>();
                ts.next();
                ret->condition = *expStack.back();
                expStack.pop_back();
                
                Expression a = parseExpression();
                if (ts.peek().value == ":") {
                    ts.next();
                    ret->ternary = true;
                    ret->ifTrue = a;
                    ret->ifFalse = parseExpression();
                } else {
                    ret->ternary = false;
                    ret->ifFalse = a;
                }

                expStack.push_back(std::make_shared<Expression>(ret));
            } else if (op == "++") {
                ts.next();
                UnaryAugmentedAssignment(Op::INC);
            } else if (op == "--") {
                ts.next();
                UnaryAugmentedAssignment(Op::DEC);
            } else if (op == "!!") {
                ts.next();
                UnaryAugmentedAssignment(Op::LNOT);
            } else {
                return Operation(op);
            }
            return false;
        }

        bool Operation(std::string op) {
            Op opcode;
            uint8_t prec;
            if (op == "+")          {opcode = Op::ADD; prec = 9;}
            else if (op == "-")     {opcode = Op::SUB; prec = 9;}
            else if (op == "*")     {opcode = Op::MUL; prec = 10;}
            else if (op == "/")     {opcode = Op::DIV; prec = 10;}
            else if (op == "%")     {opcode = Op::MOD; prec = 10;}
            else if (op == "&")     {opcode = Op::AND; prec = 5;}
            else if (op == "^")     {opcode = Op::XOR; prec = 4;}
            else if (op == "|")     {opcode = Op::OR; prec = 3;}
            else if (op == ">>")    {opcode = Op::SHR; prec = 8;}
            else if (op == "<<")    {opcode = Op::SHL; prec = 8;}
            else if (op == "&&")    {opcode = Op::LAND; prec = 2;}
            else if (op == "||")    {opcode = Op::LOR; prec = 1;}
            else if (op == "^^")    {opcode = Op::LXOR; prec = 1;}
            else if (op == "==")    {opcode = Op::SETE; prec = 6;}
            else if (op == "!=")    {opcode = Op::SETNE; prec = 6;}
            else if (op == ">")     {opcode = Op::SETG; prec = 7;}
            else if (op == "<=")    {opcode = Op::SETNG; prec = 7;}
            else if (op == "<")     {opcode = Op::SETL; prec = 7;}
            else if (op == ">=")    {opcode = Op::SETNL; prec = 7;}
            else error(UnexpectedToken, ts.peek()); // Unknown op or sum
            
            if (prec < precedence) {
                precedence = prec;
                return true;
            }
            
            std::shared_ptr<OperationExpression> ret = std::make_shared<OperationExpression>();
            ret->op = opcode;
            ret->lhs = *expStack.back();
            expStack.pop_back();
            ts.next();

            precedence = prec;
            ret->rhs = parseExpression();
            
            expStack.push_back(std::make_shared<Expression>(ret));
            return false;
        }

        void AugmentedAssignment(std::string op) {
            Op opcode;
            if (op == "+")          {opcode = Op::ADD; precedence = 9;}
            else if (op == "-")     {opcode = Op::SUB; precedence = 9;}
            else if (op == "*")     {opcode = Op::MUL; precedence = 10;}
            else if (op == "/")     {opcode = Op::DIV; precedence = 10;}
            else if (op == "%")     {opcode = Op::MOD; precedence = 10;}
            else if (op == "&")     {opcode = Op::AND; precedence = 4;}
            else if (op == "^")     {opcode = Op::XOR; precedence = 5;}
            else if (op == "|")     {opcode = Op::OR; precedence = 3;}
            else if (op == ">>")    {opcode = Op::SHR; precedence = 9;}
            else if (op == "<<")    {opcode = Op::SHL; precedence = 9;}
            else if (op == "&&")    {opcode = Op::LAND; precedence = 2;} // Here on it arguably is deranged
            else if (op == "||")    {opcode = Op::LOR; precedence = 1;}
            else if (op == "^^")    {opcode = Op::LXOR; precedence = 1;}
            else error(UnexpectedToken, ts.peek()); // Unknown op or sum

            std::shared_ptr<AssignmentExpression> ret = std::make_shared<AssignmentExpression>();
            std::shared_ptr<OperationExpression> opexp = std::make_shared<OperationExpression>();
            opexp->op = opcode;
            opexp->lhs = *expStack.back();
            ret->lhs = *expStack.back();
            ret->rhs = opexp;
            expStack.pop_back();
            expStack.push_back(std::make_shared<Expression>(ret));
        }

        void UnaryOperation(Op opcode) {
            std::shared_ptr<OperationExpression> ret = std::make_shared<OperationExpression>();
            ret->op = opcode;
            ret->lhs = parseExpression();
            expStack.push_back(std::make_shared<Expression>(ret));
        }

        void UnaryAugmentedAssignment(Op opcode) {
            std::shared_ptr<AssignmentExpression> ret = std::make_shared<AssignmentExpression>();
            std::shared_ptr<OperationExpression> opexp = std::make_shared<OperationExpression>();
            opexp->op = opcode;
            opexp->lhs = *expStack.back();
            ret->lhs = *expStack.back();
            ret->rhs = opexp;
            expStack.pop_back();
            expStack.push_back(std::make_shared<Expression>(ret));
        }
};


// Lexer

class Lexer {
    public:
        Lexer(const std::string& source) : source(source), currentPos(0), line(0), column(0) {}
    
        BufferedTokenStream tokenize() {
            std::vector<Token> tokens;
            while (currentPos < source.size()) {
                if (isspace(source[currentPos])) {
                    if (source[currentPos] == '\n') {
                        line++;
                        column = 0;
                    } else {
                        column++;
                    }
                    currentPos++;
                } else if (isalpha(source[currentPos]) || source[currentPos] == '_') {
                    tokens.push_back(identifier());
                } else if (isdigit(source[currentPos])) {
                    tokens.push_back(number());
                } else if (source[currentPos] == ';') {
                    tokens.push_back({Punctuation, ";", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == ':') {
                    if (source[currentPos+1] == ':') {
                        tokens.push_back({Punctuation, "::", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, ":", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '.') {
                    tokens.push_back({Operation, ".", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '?') {
                    tokens.push_back({Operation, "?", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '#') {
                    tokens.push_back({Punctuation, "#", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == ',') {
                    tokens.push_back({Punctuation, ",", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '(') {
                    tokens.push_back({Punctuation, "(", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == ')') {
                    tokens.push_back({Punctuation, ")", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '[') {
                    tokens.push_back({Operation, "[", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == ']') {
                    tokens.push_back({Punctuation, "]", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '{') {
                    tokens.push_back({Punctuation, "{", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '}') {
                    tokens.push_back({Punctuation, "}", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '\'') {
                    column++; currentPos++;
                    std::string s;
                    if (source[currentPos] == '\\') {
                        column++; currentPos++;
                        if (isdigit(source[currentPos])) {
                            s = std::to_string(source[currentPos]-'0');
                        } else {
                            s = std::to_string((int)escape[source[currentPos]]);
                        }
                    } else {
                        s = std::to_string((int)source[currentPos]);
                    }
                    
                    column++; currentPos++;
                    if (source[currentPos] != '\'') error(UnmatchedPunctuation, {Punctuation, "\'", line, column});
                    tokens.push_back({Integer, s, line, column-1});
                    column++; currentPos++;
                } else if (source[currentPos] == '\"') {
                    tokens.push_back({Punctuation, "[", line, column});
                    column++; currentPos++;
                    while (source[currentPos] != '\"') {
                        if (source[currentPos] == '\\') {
                            column++; currentPos++;
                            if (isdigit(source[currentPos])) {
                                tokens.push_back({Integer, std::to_string(source[currentPos]-'0'), line, column});
                            } else {
                                tokens.push_back({Integer, std::to_string((int)escape[source[currentPos]]), line, column});
                            }
                        } else {
                            tokens.push_back({Integer, std::to_string((int)source[currentPos]), line, column});
                        }
                        tokens.push_back({Punctuation, ",", line, column});
                        column++; currentPos++;
                        if (currentPos == source.size()) {
                            error(UnmatchedPunctuation, {Punctuation, "\"", line, column});
                        }
                    }
                    tokens.push_back({Integer, "0", line, column});
                    tokens.push_back({Punctuation, "]", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '=') {
                    if (source[currentPos+1] == '=') {
                        tokens.push_back({Operation, "==", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "=", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '+') {
                    if (source[currentPos+1] == '+') {
                        tokens.push_back({Operation, "++", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "+", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '-') {
                    if (source[currentPos+1] == '-') {
                        tokens.push_back({Operation, "--", line, column});
                        column++; currentPos++;
                    } else if (source[currentPos+1] == '>') {
                        tokens.push_back({Operation, "->", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "-", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '>') {
                    if (source[currentPos+1] == '>') {
                        tokens.push_back({Operation, ">>", line, column});
                        column++; currentPos++;
                    } else if (source[currentPos+1] == '=') {
                        tokens.push_back({Operation, ">=", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, ">", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '<') {
                    if (source[currentPos+1] == '<') {
                        tokens.push_back({Operation, "<<", line, column});
                        column++; currentPos++;
                    } else if (source[currentPos+1] == '=') {
                        tokens.push_back({Operation, "<=", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "<", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '/') {
                    if (source[currentPos+1] == '/') {
                        while (source[currentPos] != '\n' && source[currentPos] != 0) {
                            currentPos++;
                        }
                        line++; column = 0;
                    } else if (source[currentPos+1] == '*') {
                        column+=2; currentPos+=2;
                        while (!(source[currentPos] == '*' && source[currentPos+1] == '/')) {
                            currentPos++;
                            if (currentPos == source.size()) {
                                error(UnexpectedEOF, {Punctuation, "\"", line, column});
                            }
                            if (source[currentPos] == '\n') {
                                line++;
                                column = 0;
                            }
                            if (currentPos == source.size()) {
                                error(UnmatchedPunctuation, {Punctuation, "\"", line, column});
                            }
                        }
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "/", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '*') {
                    tokens.push_back({Operation, "*", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '%') {
                    if (source[currentPos+1] == '=') {
                        tokens.push_back({Operation, "%=", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "%", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '^') {
                    tokens.push_back({Operation, "^", line, column});
                    column++; currentPos++;
                } else if (source[currentPos] == '&') {
                    if (source[currentPos+1] == '&') {
                        tokens.push_back({Operation, "&&", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "&", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '|') {
                    if (source[currentPos+1] == '=') {
                        tokens.push_back({Operation, "||", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "|", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '!') {
                    if (source[currentPos+1] == '=') {
                        tokens.push_back({Operation, "!=", line, column});
                        column++; currentPos++;
                    } else if (source[currentPos+1] == '!') {
                        tokens.push_back({Operation, "!!", line, column});
                        column++; currentPos++;
                    } else {
                        tokens.push_back({Operation, "!", line, column});
                    }
                    column++; currentPos++;
                } else if (source[currentPos] == '~') {
                    tokens.push_back({Operation, "~", line, column});
                    column++; currentPos++;
                } else {
                    error(UnexpectedToken, {EoF, std::to_string(source[currentPos]), line, column});
                }
            }

            return BufferedTokenStream(tokens);
        }
    
    private:
        std::string source;
        size_t currentPos;
        unsigned int line, column;
    
        Token identifier() {
            std::string id;
            while (currentPos < source.size() && (isalnum(source[currentPos]) || source[currentPos] == '_')) {
                id += source[currentPos++];
                column++;
                if (id == OVERLOAD_IDENTIFIER) {
                    while (currentPos < source.size() && source[currentPos] != ':' && source[currentPos] != ' ') {
                        id += source[currentPos++];
                        column++;
                    }
                } 
            }
    
            for (int i = 0; i < KEYWORDS; i++) {
                if (reserved[i] == id) {
                    return {Keyword, id, line, (unsigned int)(column-(id.length()))};
                }
            }
    
            return {Identifier, id, line, (unsigned int)(column-(id.length()))};
        }
    
        // I think it is the lexer that should implement all parsing logic, including for floating point
        Token number() {
            unsigned int startcol = column;
            std::string num = "";
            while (currentPos < source.size() && isdigit(source[currentPos])) {
                num += source[currentPos++];
                column++;
                if ((source[currentPos] == 'x' || source[currentPos] == 'X') && num == "0") {
                    column++; currentPos++;
                    num = "";
                    while (currentPos < source.size() && (isalnum(source[currentPos]))) {
                        num += source[currentPos++];
                        column++;
                    }
                    return {Integer, std::to_string(stoi(num, nullptr, 16)), line, startcol};
                } else if ((source[currentPos] == 'b' || source[currentPos] == 'B') && num == "0") {
                    column++; currentPos++;
                    num = "";
                    while (currentPos < source.size() && (isdigit(source[currentPos]))) {
                        num += source[currentPos++];
                        column++;
                    }
                    return {Integer, std::to_string(stoi(num, nullptr, 2)), line, startcol};
                }
            }
            if (source[currentPos] == '.') {
                num += '.';
                column++; currentPos++;
                while (currentPos < source.size() && isdigit(source[currentPos])) {
                    num += source[currentPos++];
                    column++;
                }
                return {Floating, num, line, startcol};
            } else {
                return {Integer, num, line, startcol};
            }
        }
};

int main(int argc, char** argv) {
    if (argc < 2) error(NoInputFiles, {EoF, "", 0, 0});
    filename = argv[1];

    std::ifstream f(filename);
    if (!f.is_open()) {
        error(FileNotFound, {EoF, filename, 0, 0});
    }

    std::stringstream buffer;
    buffer << f.rdbuf();
    sourceCode = buffer.str();

    Lexer lexer(sourceCode);
    BufferedTokenStream tokenStream = lexer.tokenize();

    std::cout << PINK ITALIC BOLD << "bloom" <<RESET<<" | " << RESET << BOLD GRAY << "phase 1: " << RESET << "lexing done" << std::endl;

    std::cout<<std::endl;
    
    Parser parser(tokenStream);
    Ast ast = parser.parse();

    std::cout << PINK ITALIC BOLD << "bloom" <<RESET<<" | " << RESET << BOLD GRAY << "phase 2: " << RESET << "parsing done" << std::endl;
    
    for (auto x : ast) {
        printStatement(x, 0);
        std::cout<<"________"<<std::endl;
    }

    //std::cout<<std::endl;

    f.close();
}

// Honestly, symbols can be seen as members of namespaces. Maybe there is no need for separating them and it can just be identified at semantic analysis time.